Filename expansion
# shell expansion:
	> before executing, the shell "rewrites" and parses the command
	> this happens before the command is being executed

# filename expansion	
	> ls *
	> in this case, the * is being "expanded"
	> for the asterisk, this mean Bash gets the contents of the current directory
	> and passes those items as paramteres to the "ls" command
	> this command print the content of our current folder:
		echo *
	> we can also filter the files that Bash should find for us:
		example:
			- echo *.txt (filter multiple character end with .txt)
			- echo ?.txt (filter one character end with .txt)

============================================

Tilde expansion
# tilde expansion:
	> ls ~
	> this list our home folder
	> by the "~" character, we're using the tilde expansion
	> this character is being expanded to the value of the environment variable HOME
	> test this:
		$ echo ~
	> we could also use it with a plus:
		~+: expands to $PWD
		$ echo ~+

============================================

Variable and Parameter extension '${...}'
Variable expansion:
# the varaible expansion allows us to access a varaible:
	> possible ways to write it:
		$ echo $HOME
		$ echo ${HOME}
		$ echo "$HOME"
		$ echo "${HOME}"
	> Bash rewrites the command for us, and fills in the varaible
	> We should prefer to use double quotes around it
	> We should try use curly braces to make it clear where the variable end:
		$ echo "${HOME}path"
		$ echo "$HOMEpath" (something different)

Shell parameter expansion:
# shell paramter expansion allows us to work with strings
# however, we need to have a varaible first!

# query the lenght of string:
	$ ${#HOME}
# cut out a substring (substring extraction):
	$ ${#HOME:start:length}
# replace sunstring (one time):
	$ ${HOME/pattern/replacement}
# replace sunstring (all occurences):
	$ ${HOME//pattern/replacement} 

============================================

Word splitting
# bash performs word splitting on out input
# this happens, after our command has been (potentially) rewritten by expansions
# example:
	> touch a.txt b.txt
	> this command will be slitted into 3 different words:
		- touch
		- a.txt
		- b.txt
	> the first entry will then be the program (touch)
	> a.txt the first parameter / argument
	> b.txt will be the second paramter / argument
# word splitting will occur at any character that is listed in the varaible IFS
# by default, this is at very space, every tab, and every newline
# sequences of IFS characters are treated as a single delimeter
# tus, this would be equivalent:
	> touch a.txt b.txt
	> touch a.txt		b.txt
# we can disable word splittin by wrapping parts of the command into quotes:
	> touch 'a file.txt'
	> touch "a file.txt"
	> without word splitting:
		- 2 files would have been created ('a' and 'file.txt')
	> word splitting is disabled for character between those quotes



















